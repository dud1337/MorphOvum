<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Morph Ovum</title>
  <link rel="stylesheet" type="text/css" href="./style.css">
</head>
<body class="player-page">

<div id="app">
  <div class="music-player">
    <div class="player-layout">
      <div class="logo-sidebar">
        <a href="https://github.com/dud1337/MorphOvum" target="_blank" rel="noopener noreferrer" class="logo-link">
          <div class="logo-vertical">
            <span class="logo-text">MORPH</span>
            <img src="/MorphOvum.gif" alt="Egg" class="logo-egg">
            <span class="logo-text">OVUM</span>
            <span class="logo-subtitle">foss radio</span>
          </div>
        </a>
      </div>
      <div class="player-content">
        <div id="controls">
          <div id="spectrum-visualizer-container">
            <canvas id="spectrum-canvas"></canvas>
            <div id="spectrum-overlay">
              <div id="spectrum-song-label" class="spectrum-label"></div>
              <div id="spectrum-ambience-label" class="spectrum-label"></div>
            </div>
          </div>
          <div id="controls-row">
            <button id="play_button" class="play button playing-icon" aria-label="Play/Pause">&#9654;</button>
            <div id="volume-container">
              <span id="volume-icon" aria-hidden="true">ðŸ”Š</span>
              <input type="range" id="volume-control" class="slider" min="0" max="100" value="40" step="5" aria-label="Volume control">
              <span id="volume-percentage">40%</span>
              <a href="./control_panel/" class="settings-icon" target="_blank" rel="noopener noreferrer" aria-label="Control Panel">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                </svg>
              </a>
            </div>
          </div>
      </div>
      <div id="last_played_songs"></div>
      </div>
    </div>
    <div class="song-history-section">
      <span class="disableselect song-history-label">Song History</span>
      <div class="track-list-container">
        <ul class="track-list">
          <br />
        </ul>
      </div>
    </div>
  </div>
</div>
<div id="copy-toast">Copied to clipboard!</div>
<script>
  const playButton = document.querySelector('.play.button')
  const audioPlayer = new Audio()
  const volumeControl = document.getElementById('volume-control')
  const volumeIcon = document.getElementById('volume-icon')
  const volumePercentage = document.getElementById('volume-percentage')
  const copyToast = document.getElementById('copy-toast')
  
  // Audio visualization setup
  const canvas = document.getElementById('spectrum-canvas')
  const canvasCtx = canvas.getContext('2d')
  let audioContext = null
  let analyser = null
  let dataArray = null
  let bufferLength = null
  let animationId = null
  let peakValues = [] // For peak hold mode
  
  // Set canvas size
  canvas.width = canvas.offsetWidth || 600
  canvas.height = canvas.offsetHeight || 120
  
  // Load saved volume from localStorage or use default
  const savedVolume = localStorage.getItem('morphovum_volume')
  const initialVolume = savedVolume ? parseInt(savedVolume) : 40
  audioPlayer.volume = (initialVolume / 100) ** 2  // Quadratic curve for more natural volume feel
  volumeControl.value = initialVolume
  updateVolumeDisplay(initialVolume)
  
  // Initialize Web Audio API for visualization
  function initAudioContext() {
    if (audioContext) return
    
    audioContext = new (window.AudioContext || window.webkitAudioContext)()
    analyser = audioContext.createAnalyser()
    analyser.fftSize = 512
    analyser.smoothingTimeConstant = 0.8
    analyser.minDecibels = -90
    analyser.maxDecibels = -10
    
    const source = audioContext.createMediaElementSource(audioPlayer)
    source.connect(analyser)
    analyser.connect(audioContext.destination)
    
    bufferLength = analyser.frequencyBinCount
    dataArray = new Uint8Array(bufferLength)
    
    // Initialize peak values array
    peakValues = new Array(64).fill(0)
  }
  
  // Get frequency data with peak hold
  function getFrequencyData() {
    analyser.getByteFrequencyData(dataArray)
    
    const barCount = 64
    const values = []
    const nyquist = audioContext.sampleRate / 2
    
    // Balanced semi-log: 40% linear + 60% log with peak hold
    const minFreq = 30
    const maxFreq = Math.min(12000, nyquist)
    
    for (let i = 0; i < barCount; i++) {
      const t = i / barCount
      const linearPos = minFreq + t * (maxFreq - minFreq)
      const logPos = minFreq * Math.pow(maxFreq / minFreq, t)
      const freq = linearPos * 0.4 + logPos * 0.6
      
      const binIndex = Math.floor(freq / nyquist * bufferLength)
      const dataIndex = Math.min(binIndex, bufferLength - 1)
      
      let sum = 0
      const avgRange = 2
      for (let j = -avgRange; j <= avgRange; j++) {
        const idx = Math.max(0, Math.min(bufferLength - 1, dataIndex + j))
        sum += dataArray[idx]
      }
      const avgValue = sum / (avgRange * 2 + 1)
      const freqBoost = 1 + (t * 0.35)
      const currentValue = avgValue * freqBoost
      
      // Update peak with decay
      if (currentValue > peakValues[i]) {
        peakValues[i] = currentValue
      } else {
        peakValues[i] *= 0.985 // Much slower decay - peaks stay longer
      }
      
      values.push(currentValue)
    }
    
    return values
  }
  
  // Draw spectrum visualization
  function drawSpectrum() {
    if (!analyser || !playing) {
      // Draw idle state with dim bars
      canvasCtx.fillStyle = '#1a1b1e'
      canvasCtx.fillRect(0, 0, canvas.width, canvas.height)
      
      const barCount = 64
      // Adjust gap based on canvas width (tighter on smaller screens)
      const gapRatio = canvas.width < 500 ? 0.15 : 0.2
      const barWidth = (canvas.width / barCount) * (1 - gapRatio)
      const gap = (canvas.width / barCount) * gapRatio
      
      for (let i = 0; i < barCount; i++) {
        const x = i * (barWidth + gap)
        const barHeight = 8
        const y = canvas.height - barHeight
        
        // Dim light gray bars for idle state
        const gradient = canvasCtx.createLinearGradient(0, y, 0, canvas.height)
        gradient.addColorStop(0, 'rgba(139, 157, 195, 0.3)')
        gradient.addColorStop(1, 'rgba(184, 197, 214, 0.3)')
        canvasCtx.fillStyle = gradient
        canvasCtx.fillRect(x, y, barWidth, barHeight)
      }
      
      if (playing) {
        animationId = requestAnimationFrame(drawSpectrum)
      }
      return
    }
    
    animationId = requestAnimationFrame(drawSpectrum)
    
    canvasCtx.fillStyle = '#1a1b1e'
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height)
    
    const values = getFrequencyData()
    const barCount = values.length
    
    // Adjust gap based on canvas width (tighter on smaller screens)
    const gapRatio = canvas.width < 500 ? 0.15 : 0.2
    const barWidth = (canvas.width / barCount) * (1 - gapRatio)
    const gap = (canvas.width / barCount) * gapRatio
    
    for (let i = 0; i < barCount; i++) {
      const barHeight = Math.min((values[i] / 255) * canvas.height * 0.9, canvas.height * 0.95)
      
      const x = i * (barWidth + gap)
      const y = canvas.height - barHeight
      
      // Create smooth gradient for light bars
      const gradient = canvasCtx.createLinearGradient(0, y, 0, canvas.height)
      const intensity = barHeight / (canvas.height * 0.9)
      
      // Light gray gradient - softer, more subdued
      const topBrightness = 0.35 + (intensity * 0.55) // 35% to 90% brightness at top
      const bottomBrightness = 0.45 + (intensity * 0.45) // 45% to 90% brightness at bottom
      
      // Calculate RGB values for smooth light gray gradient
      const topR = Math.floor(107 + (108 * topBrightness))
      const topG = Math.floor(122 + (93 * topBrightness))
      const topB = Math.floor(146 + (69 * topBrightness))
      
      const midR = Math.floor(139 + (76 * bottomBrightness))
      const midG = Math.floor(157 + (58 * bottomBrightness))
      const midB = Math.floor(195 + (20 * bottomBrightness))
      
      const bottomR = Math.floor(175 + (40 * intensity))
      const bottomG = Math.floor(190 + (25 * intensity))
      const bottomB = Math.floor(215 + (10 * intensity))
      
      gradient.addColorStop(0, `rgba(${topR}, ${topG}, ${topB}, 0.9)`)
      gradient.addColorStop(0.5, `rgba(${midR}, ${midG}, ${midB}, 0.92)`)
      gradient.addColorStop(1, `rgba(${bottomR}, ${bottomG}, ${bottomB}, 0.95)`)
      
      canvasCtx.fillStyle = gradient
      canvasCtx.fillRect(x, y, barWidth, barHeight)
      
      // Add subtle glow for high intensity
      if (intensity > 0.65) {
        canvasCtx.shadowBlur = 8 + (intensity * 6)
        canvasCtx.shadowColor = `rgba(184, 197, 214, ${0.4 + intensity * 0.4})`
        canvasCtx.fillRect(x, y, barWidth, barHeight)
        canvasCtx.shadowBlur = 0
      }
      
      // Draw peak hold indicator in lime green
      if (peakValues[i] > 0) {
        const peakHeight = Math.min((peakValues[i] / 255) * canvas.height * 0.9, canvas.height * 0.95)
        const peakY = canvas.height - peakHeight
        
        canvasCtx.fillStyle = '#a0ff50'
        canvasCtx.fillRect(x, peakY - 2, barWidth, 3)
        
        // Glow on peak
        canvasCtx.shadowBlur = 6
        canvasCtx.shadowColor = 'rgba(160, 255, 80, 0.8)'
        canvasCtx.fillRect(x, peakY - 2, barWidth, 3)
        canvasCtx.shadowBlur = 0
      }
    }
  }
  

  function connectWebSocket() {
      var loc = window.location, new_uri;
      if (loc.protocol === "https:") {
        new_uri = "wss:";
      } else {
        new_uri = "ws:";
      }
      new_uri += "//" + loc.host + loc.pathname + 'notify';
    
      const ws = new WebSocket(new_uri)
  
      ws.addEventListener('message', (event) => {
        switch (event.data) {
          case 'music_changed':
          case 'music_paused':
            updateCurrentTrack()
            buildPlaylist()
            return
          case 'ambience_changed':
          case 'ambience_paused':
            updateCurrentAmbience()
            return
        }
      })
      ws.addEventListener("close", () => {
    connectWebSocket(); // Attempt to reconnect after connection closure
      });

      ws.addEventListener("error", (error) => {
    connectWebSocket(); // Attempt to reconnect on error
      });
  }

  connectWebSocket(); 

  const audio_resource = './listen.mp3'
  
  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    // Ignore if typing in an input field
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return
    }
    
    switch(e.key) {
      case ' ': // Space - play/pause
        e.preventDefault()
        playButton.click()
        break
      case 'ArrowUp': // Arrow Up - volume up
        e.preventDefault()
        const newVolumeUp = Math.min(100, parseInt(volumeControl.value) + 5)
        volumeControl.value = newVolumeUp
        audioPlayer.volume = (newVolumeUp / 100) ** 2  // Quadratic curve for more natural volume feel
        updateVolumeDisplay(newVolumeUp)
        localStorage.setItem('morphovum_volume', newVolumeUp)
        break
      case 'ArrowDown': // Arrow Down - volume down
        e.preventDefault()
        const newVolumeDown = Math.max(0, parseInt(volumeControl.value) - 5)
        volumeControl.value = newVolumeDown
        audioPlayer.volume = (newVolumeDown / 100) ** 2  // Quadratic curve for more natural volume feel
        updateVolumeDisplay(newVolumeDown)
        localStorage.setItem('morphovum_volume', newVolumeDown)
        break
      case 'm':
      case 'M': // M - mute/unmute
        e.preventDefault()
        volumeIcon.click()
        break
    }
  })

  let playing = false

  playButton.addEventListener('click', () => {
    const element = document.getElementById('play_button');
    if (!playing) {
      // Initialize audio context on user interaction (required by browsers)
      initAudioContext()
      if (audioContext.state === 'suspended') {
        audioContext.resume()
      }
      
      audioPlayer.src = `${audio_resource}?${Date.now()}`
      audioPlayer.load()
      audioPlayer.play()
      playing = true
      element.innerHTML = '&#x23f8;';
      element.classList.remove('playing-icon');
      element.classList.add('paused-icon');
      
      // Start visualization
      drawSpectrum()
      return
    }

    audioPlayer.pause()
    element.innerHTML = '&#9654;';
    element.classList.remove('paused-icon');
    element.classList.add('playing-icon');
    playing = false
    
    // Stop visualization animation
    if (animationId) {
      cancelAnimationFrame(animationId)
      animationId = null
    }
    
    // Draw idle state
    drawSpectrum()
  })

  function updateCurrentTrack() {
    fetch('./api/music/currenttrack')
      .then(response => response.json())
      .then(json => {
        const spectrumSongLabel = document.getElementById('spectrum-song-label')
        
        if (json.data.is_playing) {
          spectrumSongLabel.textContent = 'â™« ' + json.msg
        } else {
          spectrumSongLabel.textContent = ''
        }
      })
  }

  function updateCurrentAmbience() {
    fetch('./api/ambience/currenttrack')
      .then(response => response.json())
      .then(json => {
        const spectrumAmbienceLabel = document.getElementById('spectrum-ambience-label')
        
	if (json.data.is_playing) {
          spectrumAmbienceLabel.textContent = 'â˜® ' + json.msg
        } else {
          spectrumAmbienceLabel.textContent = ''
        }
      })
  }
  

  // Update volume icon based on level
  function updateVolumeDisplay(value) {
    const volume = parseInt(value)
    volumePercentage.textContent = volume + '%'
    
    // Update icon based on volume level
    if (volume === 0) {
      volumeIcon.textContent = 'ðŸ”‡'
    } else if (volume < 33) {
      volumeIcon.textContent = 'ðŸ”‰'
    } else if (volume < 66) {
      volumeIcon.textContent = 'ðŸ”Š'
    } else {
      volumeIcon.textContent = 'ðŸ”Š'
    }
    
    // Update slider background using CSS variable (works in Firefox)
    const percentage = volume
    volumeControl.style.setProperty('--volume-percentage', percentage + '%')
  }
  
  // Volume control handler with Firefox delay fix
  function handleVolumeChange(e) {
    // Use setTimeout to ensure Firefox has updated the value
    setTimeout(() => {
      const value = volumeControl.value
      audioPlayer.volume = (value / 100) ** 2  // Quadratic curve for more natural volume feel
      updateVolumeDisplay(value)
      localStorage.setItem('morphovum_volume', value)
    }, 0)
  }
  
  volumeControl.addEventListener("input", handleVolumeChange)
  volumeControl.addEventListener("change", handleVolumeChange)
  volumeControl.addEventListener("click", handleVolumeChange)
  
  // Click volume icon to mute/unmute
  volumeIcon.addEventListener('click', function() {
    if (audioPlayer.volume > 0) {
      volumeIcon.dataset.previousVolume = volumeControl.value
      volumeControl.value = 0
      audioPlayer.volume = 0
      updateVolumeDisplay(0)
      localStorage.setItem('morphovum_volume', '0')
    } else {
      const previousVolume = volumeIcon.dataset.previousVolume || '40'
      volumeControl.value = previousVolume
      audioPlayer.volume = (previousVolume / 100) ** 2  // Quadratic curve for more natural volume feel
      updateVolumeDisplay(previousVolume)
      localStorage.setItem('morphovum_volume', previousVolume)
    }
  })
  

  // Show toast notification
  function showToast(message) {
    copyToast.textContent = message
    copyToast.classList.add('show')
    setTimeout(() => {
      copyToast.classList.remove('show')
    }, 2000)
  }
  
  // Copy text to clipboard
  function copyToClipboard(text, element) {
    navigator.clipboard.writeText(text).then(() => {
      showToast('Copied to clipboard!')
      element.classList.add('copied')
      setTimeout(() => {
        element.classList.remove('copied')
      }, 500)
    }).catch(err => {
      console.error('Failed to copy:', err)
      showToast('Failed to copy')
    })
  }

  function buildPlaylist() {
    fetch('./api/music/history')
      .then(response => response.json())
      .then(json => {
        const listItems = json.data.reverse().slice(1).map(track => {
          const li = document.createElement('li')
          li.className = 'track-list__track'
          
          const trackText = document.createElement('span')
          trackText.className = 'track-text'
          trackText.textContent = track
          
          const copyIcon = document.createElement('span')
          copyIcon.className = 'track-copy-icon'
          copyIcon.innerHTML = 'ðŸ“‹'
          copyIcon.setAttribute('aria-label', 'Copy')
          
          li.appendChild(trackText)
          li.appendChild(copyIcon)
          
          // Click to copy functionality
          li.addEventListener('click', function() {
            copyToClipboard(track, li)
          })
          
          return li
        })
        const trackList = document.querySelector('.track-list')
        trackList.innerHTML = '';

        const trackListEnding = trackList.querySelector('br')

        listItems.forEach(li => {
          trackList.insertBefore(li, trackListEnding)
        })
      })
  }

  (() => { // init app
    updateCurrentTrack()
    updateCurrentAmbience()
    buildPlaylist()
    
    // Draw initial idle spectrum
    drawSpectrum()
    
    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = canvas.offsetWidth || 600
      canvas.height = canvas.offsetHeight || 120
      drawSpectrum()
    })
  })()
</script>
</body>
</html>
